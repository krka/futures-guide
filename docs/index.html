<!DOCTYPE html>
<html lang="en">
<head>
<title>Interactive futures tutorial</title>
<style type="text/css" media="screen">
  div.editor { 
    width: 80em;
    height: 10em;
  }
  div.lesson {
    width: 82em;
	padding: 1em;
  }
  div.verify {
    display: none;
  }
  div.passed {
    background-color: #ccffcc;
  }
  div.failed {
    background-color: #ffcccc;
  }
</style>
</head>
<body>

<h2>Intro</h2>
<p>
This is an interactive tutorial for futures. The code samples are intended to look and behave like Java but it's actually JavaScript.
"->" is automatically converted to "=>" so you can write lambdas like in Java.</p>

<p>Exceptions are similar to Java, but without anything fancy.</p>

<p>The <a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/CompletableFuture.html">CompletableFuture API</a> you can use here is a partial re-implementation in JavaScript. The functions you can use are listed below:
<p></p>
<p>Since Java 8:</p>
<ul>
<li>var x = new CompletableFuture();
<li>var x = CompletableFuture.completedFuture(value);
<li> var newFuture = future.thenApply(value -> new_value);
<li> var newFuture = future.thenCompose(value -> new_future);
<li> var newFuture = future.exceptionally(exc -> new_value);
<li> var newFuture = future.handle((value, exc) -> new_value);
</ul>
<p>Since Java 9:</p>
<ul>
<li>var x = CompletableFuture.failedFuture(exception);
</ul>
<p>Since Java 12:</p>
<ul>
<li> var newFuture = future.exceptionallyCompose(exc -> new_future);
</ul>
</p>

<div class="lesson">
<h3>Lesson 1:</h3>
<p>
Let's start by transforming a future into a new future.
</p>
<p>Challenge: return a future that has the same value as the input future, but adding a "!" at the end.
</p>
<div class="editor">
CompletableFuture<String> function(CompletableFuture<String> input) {
  // Hint: use the thenApply-method
  return null;
}
</div>
<div class="verify">
for (var i = 0; i < 10; i++) {
  var inputValue = "input-" + Math.floor(Math.random() * 1000);
  var expectedValue = inputValue + "!"
  verify(12, userFunction, Result.value(expectedValue), Result.value(inputValue));
}
</div>
</div>

<div class="lesson">
<h3>Lesson 2:</h3>
<p>
Now it's time to handle exceptions!
Your code should do the same thing as before, but if the input future
has an exception, your result future should convert the error string to "Error: " + exception
</p>
<div class="editor">
CompletableFuture<String> function(CompletableFuture<String> input) {
  // Hint: use the exceptionally-method
  return null;
}
</div>
<div class="verify">
for (var i = 0; i < 10; i++) {
  var inputValue = "input-" + Math.floor(Math.random() * 1000);
  var expectedValue = inputValue + "!"

  verify(12, userFunction, Result.value(expectedValue), Result.value(inputValue));
}
for (var i = 0; i < 10; i++) {
  var inputExc = "exc-" + Math.floor(Math.random() * 1000);
  var expectedValue = "Error: " + inputExc;

  verify(12, userFunction, Result.value(expectedValue), Result.exception(inputExc));
}
</div>
</div>


<div class="lesson">
<h3>Lesson 3: Combining futures</h3>
<p>
Now we are going to get two futures as input. Your job is to return a future that is the concatenation of the values.
</p>
<div class="editor">
CompletableFuture<String> function(CompletableFuture<String> first, CompletableFuture<String> second) {
  // Hint: use the thenCombine-method
  return null;
}
</div>
<div class="verify">
for (var i = 0; i < 10; i++) {
  var input1 = "input-" + Math.floor(Math.random() * 1000);
  var input2 = "input-" + Math.floor(Math.random() * 1000);
  var expectedValue = input1 + input2;

  verify(12, userFunction, Result.value(expectedValue), [Result.value(input1), Result.value(input2)]);
}
</div>
</div>

<div class="lesson">
<h3>Lesson 4: Combining many futures</h3>
<p>
Now we are going to get four futures as input. Your job is to return a future that is the concatenation of the values.
</p>
<div class="editor">
CompletableFuture<String> function(
  CompletableFuture<String> first,
  CompletableFuture<String> second,
  CompletableFuture<String> third,
  CompletableFuture<String> fourth) {
  // Hint: use a combination of thenCompose and thenApply
  return null;
}
</div>
<div class="verify">
for (var i = 0; i < 10; i++) {
  var input1 = "input-" + Math.floor(Math.random() * 1000);
  var input2 = "input-" + Math.floor(Math.random() * 1000);
  var input3 = "input-" + Math.floor(Math.random() * 1000);
  var input4 = "input-" + Math.floor(Math.random() * 1000);
  var expectedValue = input1 + input2 + input3 + input4;

  verify(12, userFunction, Result.value(expectedValue), [Result.value(input1), Result.value(input2), Result.value(input3), Result.value(input4)]);
}
</div>
</div>



<div class="lesson">
<h3>Lesson 5: Retry on exceptions</h3>
<p>
Now we are going to simulate a retry on exception. To simplify things, the retry logic is represented by
the retry future.
</p>
<div class="editor">
CompletableFuture<String> function(CompletableFuture<String> input, CompletableFuture<String> retry) {
  return null;
}
</div>
<div class="verify">
for (var i = 0; i < 10; i++) {
  var input = "input-" + Math.floor(Math.random() * 1000);
  var retry = "retry-" + Math.floor(Math.random() * 1000);
  verify(12, userFunction, Result.value(input), [Result.value(input), Result.value(retry)]);
}
for (var i = 0; i < 10; i++) {
  var input = "exception-" + Math.floor(Math.random() * 1000);
  var retry = "retry-" + Math.floor(Math.random() * 1000);
  verify(12, userFunction, Result.value(retry), [Result.exception(input), Result.value(retry)]);
}
</div>
</div>


<div class="lesson">
<h3>Lesson 6: Retry on exceptions - With limitations</h3>
<p>
Same as the previous lesson, but now you are not allowed to use methods defined in Java 12+.
</p>
<p>Hint: you can use CompletableFuture.completedFuture(value) to create a future that is immediately completed,
and CompletableFuture.thenCompose to reduce a future of a future to a future.
</p>
<div class="editor">
CompletableFuture<String> function(CompletableFuture<String> input, CompletableFuture<String> retry) {
  return null;
}
</div>
<div class="verify">
for (var i = 0; i < 10; i++) {
  var input = "input-" + Math.floor(Math.random() * 1000);
  var retry = "retry-" + Math.floor(Math.random() * 1000);
  verify(11, userFunction, Result.value(input), [Result.value(input), Result.value(retry)]);
}
for (var i = 0; i < 10; i++) {
  var input = "exception-" + Math.floor(Math.random() * 1000);
  var retry = "retry-" + Math.floor(Math.random() * 1000);
  verify(11, userFunction, Result.value(retry), [Result.exception(input), Result.value(retry)]);
}
</div>
</div>

    
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.0/jquery.min.js"></script>

<!-- https://cdnjs.com/libraries/ace -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.min.js" type="text/javascript" charset="utf-8"></script>
<script>
  var basePath = "https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/";
  ace.config.set("basePath", basePath);
  ace.config.set("themePath", basePath);

  class Exception {
    constructor(message) {
	  this._message = message;
	}
	
	static wrap(exc) {
	  if (exc instanceof Exception) {
	    return exc;
      } else {
	    return new Exception(exc);
	  }
	}
	
    getMessage() {
	  return this.toString();
	}
	
	toString() {
	  return this._message;
	}
  }
  
  function _assert(expr, msg) {
    if (!expr) {
	  throw new Exception("Assertion failed: " + msg);
	}
  }
  
  function _assert_exc(exc) {
    _assert(exc instanceof Exception, "Expected an exception but found " + exc);
  }
  
  class Result {
    constructor(value, exception) {
      this._value = value;
      this._exception = exception;
    }
	
	static exception(exc) {
	  return new Result(null, Exception.wrap(exc));
	}
	
	static value(value) {
	  return new Result(value, null);
	}
	
	isException() {
	  return this._exception != null;
	}

	isValue() {
	  return this._exception == null;
	}
	
	equals(other) {
	  return this._exception == other._exception && this._value == other._value;
	}
	
	toString() {
	  if (this._exception != null) {
	    return "Exception('" + this._exception.getMessage() + "')";
	  }
      return "Value('" + this._value + "')";
	}
  }
  
  class CompletableFuture {
    constructor() {
      this._result = null;
      this._callbacks = [];
    }
	
	static completedFuture(value) {
	  var newFuture = new CompletableFuture();
	  newFuture.complete(value);
	  return newFuture;
	}
    
	static failedFuture(exc) {
	  _assert(_globalLanguageLevel >= 9, "Requires Java 9+");
	  _assert_exc(exc);
	  var newFuture = new CompletableFuture();
	  newFuture.completeExceptionally(exc);
	  return newFuture;
	}
    
    thenApply(fun) {
	  return this._handle(result => {
	    if (result.isValue()) {
		  return Result.value(fun(result._value));
		} else {
		  return result;
		}
	  });
    }
    
    handle(fun) {
	  return this._handle(result => {
	    if (result.isValue()) {
		  return Result.value(fun(result._value, null));
		} else {
		  return Result.value(fun(null, result._exception));
		}
	  });
    }
    
	_handle(fun) {
      var newFuture = new CompletableFuture();
      this._addCallback(result => {
	    try {
		  newFuture._internalComplete(fun(result));
		} catch (err) {
          newFuture._internalComplete(Result.exception(err));
		}
      });
      return newFuture;
	}
	
	_handleCompose(fun) {
      var newFuture = new CompletableFuture();
      this._addCallback(result => {
	    try {
		  newFuture._internalComplete(fun(result));
		} catch (err) {
          newFuture._internalComplete(Result.exception(err));
		}
      });
      return newFuture;
	}
	
    exceptionally(fun) {
	  return this._handle(result => {
	    if (result.isException()) {
		  return Result.value(fun(result._exception));
		} else {
		  return result;
		}
	  });
    }
	
    exceptionallyCompose(fun) {
	  _assert(_globalLanguageLevel >= 12, "Requires Java 12+");
	  return this
	    .thenApply(x => CompletableFuture.completedFuture(x))
	    .exceptionally(fun)
		.thenCompose(x => x);
    }
	
	thenCompose(fun) {
      var newFuture = new CompletableFuture();
	  this.thenApply(value => {
	    try {
		  var innerFuture = fun(value);
		  _assert(innerFuture instanceof CompletableFuture, "Must return a CompletableFuture");
	      innerFuture._handle(result => newFuture._internalComplete(result));
        } catch (err) {
          newFuture._internalComplete(Result.exception(err));
		}
	  });
	  return newFuture;
	}
	
	thenCombine(other, fun) {
	  return this.thenCompose(x => other.thenApply(y => fun(x, y)));
	}
    
    _addCallback(fun) {
      if (this.isComplete()) {
        fun(this._result);
      } else {
        this._callbacks.push(fun);
      }
    }
    
    
    isComplete() {
      return this._result != null;
    }
    
	getResult() {
      if (!this.isComplete()) {
        throw "Future is not completed";
      }
	  return this._result;
	}
	
    getValue() {
	  var res = getResult();
      if (res.isException()) {
        throw "Future completed exceptionally";
      }
      return res._value;
    }
    
    complete(value) {
      this._internalComplete(Result.value(value));
    }
    
    completeExceptionally(exc) {
	  _assert_exc(exc);
      this._internalComplete(Result.exception(exc));
    }
    
    _internalComplete(result) {
      if (this.isComplete()) {
        return;
      }
      this._result = result;
      for (var callback of this._callbacks) {
        callback(result);
      }
      this._callbacks = null;
    }
    
  }
  
  function verify(languageLevel, fun, expected, inputs) {
    _globalLanguageLevel = languageLevel
    if (!Array.isArray(inputs)) {
	  inputs = [inputs];
	}
	
	var inputFutures = [];
	for (input of inputs) {
	  inputFutures.push(new CompletableFuture());
	}
	
	var outputFuture = fun(...inputFutures);
	// TODO: test various combinations of pre-completed inputs
	
	for (inputFuture of inputFutures) {
      if (inputFuture.isComplete()) {
        throw "Unexpected modification of the input future";
      }
	}

    if (outputFuture == null) {
      throw "Output is null";
    }
    
    if (!(outputFuture instanceof CompletableFuture)) {
      throw "Return value has wrong type - expected CompletableFuture";
    }
    
    if (outputFuture.isComplete()) {
      throw "Future completed before the input";
    }
	
	for (var i = 0; i < inputs.length; i++) {
	  inputFutures[i]._internalComplete(inputs[i]);
	}
	
    if (!outputFuture.isComplete()) {
      throw "Future did not depend on the input";
    }
    
	var outputResult = outputFuture.getResult();
    if (!(outputResult.equals(expected))) {
      throw "Inputs:   " + inputs + "\n" +
	        "Expected: " + expected + "\n" +
			"Actual:   " + outputResult;
    }
  }

  $(".lesson").each((index, element) => {
    var lesson = $(element);

    var verifyCode = lesson.find(".verify").get(0).textContent;
    verifyCode = verifyCode.replaceAll("&lt;", "<");
    var lessonVerify = eval("(function() { return function(userFunction) { " + verifyCode + "};})()");

	var resultDom = $('<pre/>');

    var editordiv = lesson.find(".editor").get(0);
	var s = editordiv.innerHTML;
    editordiv.textContent = s.replaceAll("<string>", "<String>").replaceAll("</string>", "");
    var editor = ace.edit(editordiv);
    editor.setTheme("ace/theme/monokai");
    editor.session.setMode("ace/mode/java");

    var run = function() {
      resultDom.text("Running...");
    
      try {
        var code = editor.getValue();
        code = code.replace("CompletableFuture<String> function", "return function");
        code = code.replaceAll("CompletableFuture<String> ", "");
        code = code.replaceAll("->", "=>");

        var userFunction = eval("(function() { " + code + ";})()");
        lessonVerify(userFunction);
        resultDom.text("Passed!");
        lesson.addClass("passed");
        lesson.removeClass("failed");
      } catch (err) {
        resultDom.text(err.toString());
        lesson.removeClass("passed");
        lesson.addClass("failed");
      }
	};
	
	lesson.append(
	  $('<button/>', {
          text: 'Run',
          click: run
      })
	);
	lesson.append(resultDom);
  });
</script>
</body>
</html>
